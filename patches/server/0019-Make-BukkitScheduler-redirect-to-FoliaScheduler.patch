From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: killerprojecte <admin@fastmcmirror.org>
Date: Sun, 2 Apr 2023 19:13:15 +0800
Subject: [PATCH] Make BukkitScheduler redirect to FoliaScheduler


diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index 12feb739a784a0108256451a37d94d041b7a5cdc..2a5c2ac38be8687f8166064394e0f676564efa01 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -12,6 +12,8 @@ import com.google.gson.JsonPrimitive;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.chunk.system.io.RegionFileIOThread;
 import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
 import io.papermc.paper.util.WorldUtil;
@@ -21,6 +23,7 @@ import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.Main;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ChunkMap;
 import net.minecraft.server.level.ServerLevel;
@@ -33,6 +36,8 @@ import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
 import org.slf4j.Logger;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -40,6 +45,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -1729,53 +1736,63 @@ public final class NewChunkHolder {
     public static final record SaveStat(boolean savedChunk, boolean savedEntityChunk, boolean savedPoiChunk) {}
 
     public SaveStat save(final boolean shutdown, final boolean unloading) {
-        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
-
-        ChunkAccess chunk = this.getCurrentChunk();
-        PoiChunk poi = this.getPoiChunk();
-        ChunkEntitySlices entities = this.getEntityChunk();
-        boolean executedUnloadTask = false;
-
-        if (shutdown) {
-            // make sure that the async unloads complete
-            if (this.unloadState != null) {
-                // must have errored during unload
-                chunk = this.unloadState.chunk();
-                poi = this.unloadState.poiChunk();
-                entities = this.unloadState.entityChunk();
-            }
-            final UnloadTask chunkUnloadTask = this.chunkDataUnload;
-            final DelayedPrioritisedTask chunkDataUnloadTask = chunkUnloadTask == null ? null : chunkUnloadTask.task();
-            if (chunkDataUnloadTask != null) {
-                final PrioritisedExecutor.PrioritisedTask unloadTask = chunkDataUnloadTask.getTask();
-                if (unloadTask != null) {
-                    executedUnloadTask = unloadTask.execute();
+        //TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
+
+        //Folia (Third Party) - Automatic using region task to save data
+        CompletableFuture<SaveStat> future = new CompletableFuture<>();
+        RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(this.world, this.chunkX, this.chunkZ, () -> {
+            ChunkAccess chunk = this.getCurrentChunk();
+            PoiChunk poi = this.getPoiChunk();
+            ChunkEntitySlices entities = this.getEntityChunk();
+            boolean executedUnloadTask = false;
+
+            if (shutdown) {
+                // make sure that the async unloads complete
+                if (this.unloadState != null) {
+                    // must have errored during unload
+                    chunk = this.unloadState.chunk();
+                    poi = this.unloadState.poiChunk();
+                    entities = this.unloadState.entityChunk();
+                }
+                final UnloadTask chunkUnloadTask = this.chunkDataUnload;
+                final DelayedPrioritisedTask chunkDataUnloadTask = chunkUnloadTask == null ? null : chunkUnloadTask.task();
+                if (chunkDataUnloadTask != null) {
+                    final PrioritisedExecutor.PrioritisedTask unloadTask = chunkDataUnloadTask.getTask();
+                    if (unloadTask != null) {
+                        executedUnloadTask = unloadTask.execute();
+                    }
                 }
             }
-        }
 
-        boolean canSaveChunk = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) &&
-                                (chunk != null && ((shutdown || chunk instanceof LevelChunk) && chunk.isUnsaved()));
-        boolean canSavePOI = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) && (poi != null && poi.isDirty());
-        boolean canSaveEntities = entities != null;
+            boolean canSaveChunk = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) &&
+                (chunk != null && ((shutdown || chunk instanceof LevelChunk) && chunk.isUnsaved()));
+            boolean canSavePOI = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) && (poi != null && poi.isDirty());
+            boolean canSaveEntities = entities != null;
 
-        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
-            if (canSaveChunk) {
-                canSaveChunk = this.saveChunk(chunk, unloading);
-            }
-            if (canSavePOI) {
-                canSavePOI = this.savePOI(poi, unloading);
-            }
-            if (canSaveEntities) {
-                // on shutdown, we need to force transient entity chunks to save
-                canSaveEntities = this.saveEntities(entities, unloading || shutdown);
-                if (unloading || shutdown) {
-                    this.lastEntityUnload = null;
+            try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
+                if (canSaveChunk) {
+                    canSaveChunk = this.saveChunk(chunk, unloading);
+                }
+                if (canSavePOI) {
+                    canSavePOI = this.savePOI(poi, unloading);
+                }
+                if (canSaveEntities) {
+                    // on shutdown, we need to force transient entity chunks to save
+                    canSaveEntities = this.saveEntities(entities, unloading || shutdown);
+                    if (unloading || shutdown) {
+                        this.lastEntityUnload = null;
+                    }
                 }
             }
-        }
 
-        return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI): null;
+            SaveStat saveStat = executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI): null;
+            future.complete(saveStat);
+        }, PrioritisedExecutor.Priority.HIGHEST);
+        try {
+            return future.get();
+        } catch (InterruptedException | ExecutionException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     static final class AsyncChunkSerializeTask implements Runnable {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index c6c31416fb21e180f5c05baca93630c5d14e0abb..78e56667fcfb3df7cc046d5c1d0cf8d2a7ec638e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -7,6 +7,8 @@ import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+
 import net.minecraft.core.PositionImpl;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
@@ -578,9 +580,9 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     @Override
     public boolean teleport(Location location, TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
         // Folia start - region threading
-        if (true) {
-            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
-        }
+        //if (true) {
+        //    throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+        //}
         // Folia end - region threading
         // Paper end
         Preconditions.checkArgument(location != null, "location cannot be null");
@@ -607,20 +609,13 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         // If this entity is riding another entity, we must dismount before teleporting.
         if (dismount) this.entity.stopRiding(); // Paper - Teleport passenger API
 
-        // Let the server handle cross world teleports
-        if (location.getWorld() != null && !location.getWorld().equals(this.getWorld())) {
-            // Prevent teleportation to an other world during world generation
-            Preconditions.checkState(!entity.generation, "Cannot teleport entity to an other world during world generation");
-            this.entity.teleportTo(((CraftWorld) location.getWorld()).getHandle(), new PositionImpl(location.getX(), location.getY(), location.getZ()));
-            return true;
+        try {
+            return teleportAsync(location, cause).get();
+        } catch (InterruptedException | ExecutionException e) {
+            throw new RuntimeException(e);
         }
 
-        // entity.setLocation() throws no event, and so cannot be cancelled
-        entity.moveTo(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch()); // Paper - use proper moveTo, as per vanilla teleporting
-        // SPIGOT-619: Force sync head rotation also
-        this.entity.setYHeadRot(location.getYaw());
-
-        return true;
+        // Let the server handle cross world teleports
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 9136fb30db749737e9f189d0901024fcad02e402..293a3d934074005a7e8e224718e178bc1a3d1d09 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -7,11 +7,7 @@ import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.PriorityQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
@@ -20,7 +16,9 @@ import java.util.logging.Level;
 import com.destroystokyo.paper.ServerSchedulerReportingWrapper;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerSchedulerException;
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
 import org.apache.commons.lang.Validate;
+import org.bukkit.Bukkit;
 import org.bukkit.plugin.IllegalPluginAccessException;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitRunnable;
@@ -533,15 +531,39 @@ public class CraftScheduler implements BukkitScheduler {
     }
 
     protected CraftTask handle(final CraftTask task, final long delay) { // Paper
-        if (true) throw new UnsupportedOperationException(); // Folia - region threading
+        //Folia (Third Party) - support more plugins
+        //if (true) throw new UnsupportedOperationException(); // Folia - region threading
         // Paper start
         if (!this.isAsyncScheduler && !task.isSync()) {
-            this.asyncScheduler.handle(task, delay);
+            long mdelay = (long) (delay / 20.0 * 1000.0);
+            ScheduledTask scheduledTask;
+            if (mdelay <= 0) {
+                scheduledTask = Bukkit.getAsyncScheduler().runNow(task.getOwner(), stask -> {
+                    task.run();
+                });
+            } else {
+                scheduledTask = Bukkit.getAsyncScheduler().runDelayed(task.getOwner(), stask -> {
+                    task.run();
+                }, mdelay, TimeUnit.MILLISECONDS);
+            }
+            task.setScheduledTask(scheduledTask);
+            //this.asyncScheduler.handle(task, delay);
             return task;
         }
         // Paper end
-        task.setNextRun(this.currentTick + delay);
-        this.addTask(task);
+        //task.setNextRun(this.currentTick + delay);
+        //this.addTask(task);
+        ScheduledTask scheduledTask;
+        if (delay <= 0) {
+            scheduledTask = Bukkit.getGlobalRegionScheduler().run(task.getOwner(), stask -> {
+                task.run();
+            });
+        } else {
+            scheduledTask = Bukkit.getGlobalRegionScheduler().runDelayed(task.getOwner(), stask -> {
+                task.run();
+            }, delay);
+        }
+        task.setScheduledTask(scheduledTask);
         return task;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
index 3f45bab0e9f7b3697e6d9d1092a1e6e579f7066f..eb6bbec11cbffd79f6b971ecc58454f00704bc58 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.scheduler;
 import java.util.function.Consumer;
 
 import co.aikar.timings.NullTimingHandler;
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
 import org.bukkit.Bukkit;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitTask;
@@ -35,6 +36,7 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
     private final Plugin plugin;
     private final int id;
     private final long createdAt = System.nanoTime();
+    private ScheduledTask scheduledTask;
 
     CraftTask() {
         this(null, null, CraftTask.NO_REPEATING, CraftTask.NO_REPEATING);
@@ -139,12 +141,12 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
 
     @Override
     public boolean isCancelled() {
-        return (this.period == CraftTask.CANCEL);
+        return scheduledTask.isCancelled();
     }
 
     @Override
     public void cancel() {
-        Bukkit.getScheduler().cancelTask(id);
+        scheduledTask.cancel();
     }
 
     /**
@@ -157,4 +159,8 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
         return true;
     }
 
+    protected void setScheduledTask(ScheduledTask scheduledTask) {
+        this.scheduledTask = scheduledTask;
+    }
+
 }
