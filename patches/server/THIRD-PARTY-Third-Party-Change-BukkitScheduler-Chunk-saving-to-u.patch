From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AnswerForMystery <jim20071128@163.com>
Date: Sun, 2 Apr 2023 18:21:04 +0800
Subject: [PATCH] [Third Party] Change BukkitScheduler / Chunk saving to use
 Folia Scheduler


diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index 12feb739a784a0108256451a37d94d041b7a5cdc..2a5c2ac38be8687f8166064394e0f676564efa01 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -12,6 +12,8 @@ import com.google.gson.JsonPrimitive;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.chunk.system.io.RegionFileIOThread;
 import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
 import io.papermc.paper.util.WorldUtil;
@@ -21,6 +23,7 @@ import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.Main;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ChunkMap;
 import net.minecraft.server.level.ServerLevel;
@@ -33,6 +36,8 @@ import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
 import org.slf4j.Logger;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -40,6 +45,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -1729,53 +1736,63 @@ public final class NewChunkHolder {
     public static final record SaveStat(boolean savedChunk, boolean savedEntityChunk, boolean savedPoiChunk) {}
 
     public SaveStat save(final boolean shutdown, final boolean unloading) {
-        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
-
-        ChunkAccess chunk = this.getCurrentChunk();
-        PoiChunk poi = this.getPoiChunk();
-        ChunkEntitySlices entities = this.getEntityChunk();
-        boolean executedUnloadTask = false;
-
-        if (shutdown) {
-            // make sure that the async unloads complete
-            if (this.unloadState != null) {
-                // must have errored during unload
-                chunk = this.unloadState.chunk();
-                poi = this.unloadState.poiChunk();
-                entities = this.unloadState.entityChunk();
-            }
-            final UnloadTask chunkUnloadTask = this.chunkDataUnload;
-            final DelayedPrioritisedTask chunkDataUnloadTask = chunkUnloadTask == null ? null : chunkUnloadTask.task();
-            if (chunkDataUnloadTask != null) {
-                final PrioritisedExecutor.PrioritisedTask unloadTask = chunkDataUnloadTask.getTask();
-                if (unloadTask != null) {
-                    executedUnloadTask = unloadTask.execute();
+        //TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
+
+        //Folia (Third Party) - Automatic using region task to save data
+        CompletableFuture<SaveStat> future = new CompletableFuture<>();
+        RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(this.world, this.chunkX, this.chunkZ, () -> {
+            ChunkAccess chunk = this.getCurrentChunk();
+            PoiChunk poi = this.getPoiChunk();
+            ChunkEntitySlices entities = this.getEntityChunk();
+            boolean executedUnloadTask = false;
+
+            if (shutdown) {
+                // make sure that the async unloads complete
+                if (this.unloadState != null) {
+                    // must have errored during unload
+                    chunk = this.unloadState.chunk();
+                    poi = this.unloadState.poiChunk();
+                    entities = this.unloadState.entityChunk();
+                }
+                final UnloadTask chunkUnloadTask = this.chunkDataUnload;
+                final DelayedPrioritisedTask chunkDataUnloadTask = chunkUnloadTask == null ? null : chunkUnloadTask.task();
+                if (chunkDataUnloadTask != null) {
+                    final PrioritisedExecutor.PrioritisedTask unloadTask = chunkDataUnloadTask.getTask();
+                    if (unloadTask != null) {
+                        executedUnloadTask = unloadTask.execute();
+                    }
                 }
             }
-        }
 
-        boolean canSaveChunk = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) &&
-                                (chunk != null && ((shutdown || chunk instanceof LevelChunk) && chunk.isUnsaved()));
-        boolean canSavePOI = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) && (poi != null && poi.isDirty());
-        boolean canSaveEntities = entities != null;
+            boolean canSaveChunk = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) &&
+                (chunk != null && ((shutdown || chunk instanceof LevelChunk) && chunk.isUnsaved()));
+            boolean canSavePOI = !(chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) && (poi != null && poi.isDirty());
+            boolean canSaveEntities = entities != null;
 
-        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
-            if (canSaveChunk) {
-                canSaveChunk = this.saveChunk(chunk, unloading);
-            }
-            if (canSavePOI) {
-                canSavePOI = this.savePOI(poi, unloading);
-            }
-            if (canSaveEntities) {
-                // on shutdown, we need to force transient entity chunks to save
-                canSaveEntities = this.saveEntities(entities, unloading || shutdown);
-                if (unloading || shutdown) {
-                    this.lastEntityUnload = null;
+            try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
+                if (canSaveChunk) {
+                    canSaveChunk = this.saveChunk(chunk, unloading);
+                }
+                if (canSavePOI) {
+                    canSavePOI = this.savePOI(poi, unloading);
+                }
+                if (canSaveEntities) {
+                    // on shutdown, we need to force transient entity chunks to save
+                    canSaveEntities = this.saveEntities(entities, unloading || shutdown);
+                    if (unloading || shutdown) {
+                        this.lastEntityUnload = null;
+                    }
                 }
             }
-        }
 
-        return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI): null;
+            SaveStat saveStat = executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI): null;
+            future.complete(saveStat);
+        }, PrioritisedExecutor.Priority.HIGHEST);
+        try {
+            return future.get();
+        } catch (InterruptedException | ExecutionException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     static final class AsyncChunkSerializeTask implements Runnable {
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 9136fb30db749737e9f189d0901024fcad02e402..816e99535753e6b050a319e05ef1f848871f4541 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -7,11 +7,7 @@ import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.PriorityQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
@@ -20,7 +16,9 @@ import java.util.logging.Level;
 import com.destroystokyo.paper.ServerSchedulerReportingWrapper;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerSchedulerException;
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
 import org.apache.commons.lang.Validate;
+import org.bukkit.Bukkit;
 import org.bukkit.plugin.IllegalPluginAccessException;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitRunnable;
@@ -533,15 +531,24 @@ public class CraftScheduler implements BukkitScheduler {
     }
 
     protected CraftTask handle(final CraftTask task, final long delay) { // Paper
-        if (true) throw new UnsupportedOperationException(); // Folia - region threading
+        //Folia (Third Party) - support more plugins
+        //if (true) throw new UnsupportedOperationException(); // Folia - region threading
         // Paper start
         if (!this.isAsyncScheduler && !task.isSync()) {
-            this.asyncScheduler.handle(task, delay);
+            ScheduledTask scheduledTask = Bukkit.getAsyncScheduler().runDelayed(task.getOwner(), stask -> {
+                task.run();
+            }, (long) (delay / 20.0 * 1000.0), TimeUnit.MILLISECONDS);
+            task.setScheduledTask(scheduledTask);
+            //this.asyncScheduler.handle(task, delay);
             return task;
         }
         // Paper end
-        task.setNextRun(this.currentTick + delay);
-        this.addTask(task);
+        //task.setNextRun(this.currentTick + delay);
+        //this.addTask(task);
+        ScheduledTask scheduledTask = Bukkit.getGlobalRegionScheduler().runDelayed(task.getOwner(), stask -> {
+            task.run();
+        }, delay);
+        task.setScheduledTask(scheduledTask);
         return task;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
index 3f45bab0e9f7b3697e6d9d1092a1e6e579f7066f..eb6bbec11cbffd79f6b971ecc58454f00704bc58 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.scheduler;
 import java.util.function.Consumer;
 
 import co.aikar.timings.NullTimingHandler;
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
 import org.bukkit.Bukkit;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitTask;
@@ -35,6 +36,7 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
     private final Plugin plugin;
     private final int id;
     private final long createdAt = System.nanoTime();
+    private ScheduledTask scheduledTask;
 
     CraftTask() {
         this(null, null, CraftTask.NO_REPEATING, CraftTask.NO_REPEATING);
@@ -139,12 +141,12 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
 
     @Override
     public boolean isCancelled() {
-        return (this.period == CraftTask.CANCEL);
+        return scheduledTask.isCancelled();
     }
 
     @Override
     public void cancel() {
-        Bukkit.getScheduler().cancelTask(id);
+        scheduledTask.cancel();
     }
 
     /**
@@ -157,4 +159,8 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
         return true;
     }
 
+    protected void setScheduledTask(ScheduledTask scheduledTask) {
+        this.scheduledTask = scheduledTask;
+    }
+
 }
